---
description: Project overview, architecture, and conventions for DaggerheartGM
alwaysApply: true
---

# DaggerheartGM

A GM tool for the Daggerheart tabletop RPG. Built as a Node.js/Express server that serves a self-contained SPA.

## Architecture

- `server.js` — Express server entry point. Serves static files from `public/` and falls back to `public/index.html` for any unmatched route (standard SPA behavior). API routes live here. On startup, runs DB migrations if `DATABASE_URL` is set.
- `src/client/app.jsx` — React SPA entry point. Imports from `./lib/api.js`, mounts via `ReactDOM.createRoot`. Manages top-level state (data, activeElements, user). Uses `useRouter()` from `./lib/router.js` to derive the active view from the URL; all navigation calls `navigate()` so the browser back/forward buttons work. The nav bar user menu (click your name/email) provides Export JSON, Import JSON, and Sign Out.
- `src/client/components/` — UI components: `LibraryView.jsx`, `GMTableView.jsx`, `NavBtn.jsx`, `ItemCard.jsx`, `ItemDetailView.jsx`.
- `src/client/components/forms/` — Item creation/edit forms: `AdversaryForm`, `EnvironmentForm`, `GroupForm`, `SceneForm`, `AdventureForm`, plus shared inputs `ExperiencesInput`, `FeaturesInput`, `FormRow`, `MultiSelectRef`.
- `src/client/components/modals/` — Import modals: `RolzImportModal.jsx`, `FCGImportModal.jsx`.
- `src/client/lib/` — Client-side utilities: `api.js` (Firebase init + fetch helpers), `helpers.js` (`generateId`), `constants.js`, `rolz-parser.js`, `rolz-export.js`, `router.js` (History API router: `useRouter()` hook + `parseRoute()`).
- `src/db.js` — Postgres connection pool, migration runner, and query helpers (`getItems`, `upsertItem`, `deleteItem`).
- `src/fcg-scraper.js` — Puppeteer-based scraper for FreshCutGrass.app homebrew pages. Exports `validateFCGUrl(url)` and `scrapeFCG(url)`. Launches headless Chrome, clicks each adversary card to open its detail modal, and returns `{ adversaries, environments }` shaped for import.
- `src/input.css` — Tailwind CSS entry point (`@import "tailwindcss"`). Tailwind v4 scans `public/**/*.{html,jsx}` and `src/client/**/*.jsx` automatically.
- `migrations/` — Numbered `.sql` migration files (e.g. `001_create_items_table.sql`). Applied automatically at startup via `src/db.js`. Add new files here to evolve the schema.
- `public/index.html` — Thin HTML shell. Links to the locally-built `public/styles.css`, loads Babel standalone and an ES importmap (pointing to esm.sh CDN for React 18, Firebase 10, Lucide React). Loads the app via `<script type="module" src="/app.js">`.
- `public/styles.css` — Generated Tailwind CSS output. Do **not** edit by hand; rebuild with `npm run build:css`.
- `public/` — All static assets (images, fonts, compiled JS, etc.) go here.
- `package.json` — Uses ES modules (`"type": "module"`). Dependencies: `express`, `pg`, `firebase-admin`, `puppeteer`. Dev dependencies: `tailwindcss`, `@tailwindcss/cli`.

## Database

Supabase Postgres (or any Postgres). Set `DATABASE_URL` in `.env` to the connection string (URI format). Migrations run automatically on server start.

Schema uses a single `items` table:
- `(app_id, collection, id)` — composite primary key
- `user_id` — Firebase UID; all queries are scoped per user
- `data` — JSONB blob storing the full entity
- `app_id` — from `APP_ID` env var; namespaces data per deployment

## API Routes

- `GET /api/config` — Returns `{ firebaseConfig }` (no auth required). Consumed by `app.jsx` at startup.
- `GET /api/data` — Returns `{ adversaries, environments, groups, scenes, adventures }` for the authenticated user.
- `PUT /api/data/:collection` — Upsert an item (body is the item JSON). Returns the saved item.
- `DELETE /api/data/:collection/:id` — Delete an item.
- `GET /api/fetch-fcg?url=<fcg-url>` — Requires auth. Uses Puppeteer to scrape a FreshCutGrass.app homebrew page and returns `{ adversaries, environments }` ready for import. URL must start with `https://freshcutgrass.app/homebrew/`. Takes 20–40 seconds.

All `/api/data` routes require an `Authorization: Bearer <Firebase ID token>` header. The server verifies the token via `firebase-admin` (uses `FIREBASE_PROJECT_ID`; no service account key needed).

## Node / nvm

Node is managed via nvm. The active binary is at:

```
/Users/andrewreutter/.nvm/versions/node/v25.2.1/bin/node
```

When running `node`, `npm`, or `nvm` commands in a shell that may not have sourced `.bashrc`/`.zshrc`, use the full path or prepend the bin directory:

```bash
export PATH="/Users/andrewreutter/.nvm/versions/node/v25.2.1/bin:$PATH"
```

## Running the App

```bash
npm install         # first time only
npm run build:css   # (re)generate public/styles.css from src/input.css
npm run dev         # development: starts server (--watch) + Tailwind watcher in parallel
npm start           # production (run npm run build:css first if styles changed)
```

Server listens on `process.env.PORT` or `3456` by default. Set `PORT` in `.env` to override — both `npm start` and `npm run dev` load `.env` automatically via `node --env-file=.env`.

## Conventions

- API routes: add `app.get/post/...('/api/...')` handlers in `server.js` before the static middleware.
- Static assets: place in `public/`.
- ES modules (`import`/`export`) throughout — no `require()`.
- Routing: use `useRouter()` / `navigate()` from `src/client/lib/router.js` for all view transitions. URL scheme: `/` (home/sign-in), `/library/:tab`, `/library/:tab/new`, `/library/:tab/:id`, `/library/:tab/:id/edit`, `/gm-table`.

## Maintaining Documentation

Whenever you make structural changes to this project — adding or removing files/directories, introducing new dependencies, establishing new conventions, changing UI layout, or adding API routes — you **must** update **both** of the following as a mandatory step in every plan:

1. **`.cursor/rules/project.mdc`** (this file) — keep the architecture bullets, API routes, and conventions accurate.
2. **`README.md`** — keep the directory tree and architecture description in sync.

This is not optional or an afterthought. Every plan that touches project structure must include a dedicated "Update documentation" step covering both files.
